# Пример проекта spring boot + gradle
Этот пример показывает как  настроить Java spring boot приложение для работы во внутренней сети, построить и протестировать пакет jar,
упаковать его в docker container.

Код проекта взят с [gradle-sample-app](https://github.com/codefresh-contrib/gradle-sample-app) и адаптирован в части конфигурации.

# Как построить
В самом простом случае, когда код проекта находится в среде разработчика построить его можно из текущей папки командой: `gradlew build`.
Эта команда - оболочка, которая если нужно скачивет gradle и строит пакет приложения в текущей папке.

Пакет приложения может быть построен как в среде разработчика, так и в рабочей области CI, так и в контейнере. 
В любом случае, после того, как jar построен, он упаковывается в образ контейнера, который конфигурируется его исполнить при старте.

## Построение в docker
Цель этого примера показать как построить контейнер с упакованным в нем приложении.
Преимущество построения в контейнере состоит в том, что билд не зависит от системных зависимостей, установленных на исполняющем сервере/станции/VDI.

Будут показаны разные подходы, но некоторые ограничения и рекомендации являются общими.

В документе приводятся примеры с использованием команды "podman". Те-же команды могут выполняться с командой "docker".

Запустить контейнер:
```
podman run -it --rm -v `pwd`/spring-boot-docker:/workspace:z -p 8080:8080 registry.access.redhat.com/ubi8/openjdk-11 /bin/bash
```
В этом примере папка с исходным кодом spring-boot-docker монтируется в контейнере в папке /workspace. 
Используется рекомендованый образ контейнера ubi8/openjdk-11 и при запуске пользователь оказывается в интерактивном шелле.

Первая проблема: без дополнительных манипуляций файлы в /workspace относятся к пользователю root, но контейнер запускается с обычным, непривилегированным юзером.
Т.е. папка /workspace недоступна для записи. Чтобы решить эту проблему билд перенаправляется в другие папки, доступные для записи:
* -PbuildDir=/tmp/build - местоположение директории build, куда записываются артефакты
* -p /workspace - указание местоположения исходного кода
* --project-cache-dir=/tmp/cache - перенаправление кэша билда

Постоить приложение в контейнере:
```
/workspace/gradlew --no-daemon -p /workspace --project-cache-dir=/tmp/cache -PbuildDir=/tmp/build test bootJar
```

В результате продукты билда будут записаны в /tmp/build, в частности пакет jar будет в /tmp/build/libs/spring-boot-docker-0.0.1-SNAPSHOT.jar.
Откуда он может быть запущен командой `java -jar /tmp/build/libs/spring-boot-docker-0.0.1-SNAPSHOT.jar` которая запустит spring boot сервис на порту 8080.

Из другого окна рабочей среды, из браузера, например, приложение, исполняемое в контейнере, доступно по адресу http://localhost:8080. 
Дополнительно по адресу http://localhost:8080/actuator/health доступен health check.

## Построение образа контейнера
Образ контейнера можно построить несколькими способами, наиболее популярный - с использованием Dockerfile.
Dockerfile - текстовый файл, содержащий команды и конфигурации образа.

## Двуступенчатый билд
Такой билд определяет 2 контейнера: один, в котором установлены инструменты для построения и где происходит построение приложения из исходниковм и второй - минимизированный контейнер, содержащий только то, что необходимо для исполнения приложения.
Преимуществом такого подхода в том, что контейнеры приложений получаются меньше по размеру и в них установлено меньше компонентов, что понижает количество уязвимостей в них.

Контейнеры, используемые в примере:
* registry.access.redhat.com/ubi8/openjdk-11 - контейнер, где строится пакет jar; в нем установлен полный Java SDK.
* registry.access.redhat.com/ubi8/openjdk-11-runtime - контейнер из которого строится контейнер приложения; содержит минимальный набор, необходимый для исполнения пакета приложения

* user: jboss:root
* home: /home/jboss
* файл построения контейнера: Dockerfile

Команда построения контейнера: `podman build -t spring-boot-docker:1.0.0 .`

Контейнер запускается командой: `podman run -d -p 8080:8080 spring-boot-docker:1.0.0`

# Настройки
Вышеприведенные примеры работают в среде, где доступен интернет: из интернета скачиваются зависимости, включая gradle. Во внутренних сетях доступа к интернету нет.
Репозитории Nexus предоставляют локальные копии внешних каталогов с зависимостями Java.

## Gradle wrapper
Graddle wrapper скачивает архив gradle с адреса, прописанного в gradle/wrapper/gradle-wrapper.properties: distributionUrl. 
Для работы во внутренних сетях этот параметр должен быть переконфигурирован:
```
distributionUrl=
```
## Зависимости


